<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>IndoorJSON Preview Viewer (v6) — Overlay + Route</title>
<script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
<script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script>

<style>
:root{--bg:#fff;--fg:#111;--muted:#666;--border:#e6e6e6;--panel:#fafafa}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--fg)}
#app{display:grid;grid-template-columns:390px 1fr;height:100vh}
#side{border-right:1px solid var(--border);padding:14px;overflow:auto;background:var(--panel)}
#main{position:relative}
.block{margin-bottom:14px}
.label{font-size:12px;color:var(--muted);margin-bottom:6px}
input[type=file],select,button{width:100%;padding:10px;box-sizing:border-box;border:1px solid var(--border);border-radius:10px;background:#fff}
button{cursor:pointer}
.row{display:flex;gap:10px}
.row>*{flex:1}
#tabs{display:flex;gap:10px;margin-top:10px;flex-wrap:wrap}
#tabs button{width:auto;padding:10px 12px;border-radius:999px}
#tabs button.active{background:#111;color:#fff;border-color:#111}
#plots{position:absolute;inset:0}
.plot{position:absolute;inset:0;display:none}
.plot.active{display:block}
#status,#statusResult,#statusRoute{font-size:12px;color:var(--muted)}
pre{white-space:pre-wrap;word-break:break-word;font-size:12px;background:#fff;border:1px solid var(--border);border-radius:10px;padding:10px}
.tiny{font-size:11px;color:var(--muted);margin-top:6px}
.checkrow{display:flex;align-items:center;gap:8px;font-size:13px}
.checkrow input{width:auto}
.pill{font-size:11px;padding:2px 8px;border-radius:999px;border:1px solid var(--border);background:#fff;color:var(--muted);display:inline-block}
</style>
</head>
<body>
<div id="app">
<aside id="side">
  <div class="block">
    <div class="label">Load IndoorJSON (base)</div>
    <input id="file" type="file" accept=".json,application/json"/>
    <div id="status" style="margin-top:8px;">No file loaded.</div>
    <div class="tiny">Standalone — reads JSON locally in the browser.</div>
  </div>

  <div class="block">
    <div class="label">View</div>
    <div id="tabs">
      <button id="btn3d" class="active">3D</button>
      <button id="btn2d">2D</button>
    </div>
  </div>

  <div class="block">
    <div class="label">Level</div>
    <select id="level"><option value="__all__">All</option></select>
    <div class="checkrow" style="margin-top:8px;">
      <input id="toggleDual" type="checkbox" />
      <label for="toggleDual">Show dual graph (nodes & edges)</label>
    </div>
    <div class="tiny">Base geometry grouped by CellSpace.level (if present). Route can be multi-level.</div>
  </div>

  <div class="block">
    <div class="label">Overlay query result (IndoorJSON-shaped)</div>
    <input id="fileResult" type="file" accept=".json,application/json,.geojson,application/geo+json"/>
    <div id="statusResult" style="margin-top:8px;">No result loaded.</div>
    <div class="checkrow" style="margin-top:8px;">
      <input id="toggleResult" type="checkbox" checked/><label for="toggleResult">Show result overlay</label>
    </div>
  </div>

  <div class="block">
    <div class="label">Route result</div>
    <input id="fileRoute" type="file" accept=".json,application/json,.geojson,application/geo+json"/>
    <div id="statusRoute" style="margin-top:8px;">No route loaded.</div>
    <div class="checkrow" style="margin-top:8px;">
      <input id="toggleRoute" type="checkbox" checked/><label for="toggleRoute">Show route</label>
    </div>
    <div class="checkrow" style="margin-top:8px;">
      <input id="toggleRouteStitch" type="checkbox" />
      <label for="toggleRouteStitch">Auto-stitch route (undirected / reorder segments)</label>
    </div>
    <div class="checkrow" style="margin-top:8px;">
      <input id="toggleSegMarkers" type="checkbox" checked />
      <label for="toggleSegMarkers">Show segment boundary markers</label>
    </div>
    <div class="checkrow" style="margin-top:8px;">
      <input id="toggleSegLabels" type="checkbox" />
      <label for="toggleSegLabels">Show segment labels (on screen)</label>
    </div>


    <div class="tiny">
      Accepted route shapes:<br/>
      • IndoorJSON routing query results<br/>
      • <span class="pill">LineString</span>: [[x,y],[x,y,z],...]<br/>
      • <span class="pill">nodeMember</span>/<span class="pill">hop</span>: ["1", ...]<br/>
      • <span class="pill">edgeMember</span>/<span class="pill">cost</span>: (weight or length)<br/>
    </div>
  </div>

  <div class="block">
    <div class="label">Options</div>
    <div class="row">
      <button id="fit">Fit view</button>
      <button id="reset">Reset</button>
    </div>
  </div>

  <div class="block">
    <div class="label">Selection</div>
    <pre id="sel">{}</pre>
  </div>

  <div class="block">
    <div class="label">Cursor (2D)</div>
    <pre id="cursor">Move mouse over the 2D view…</pre>
    <div class="tiny">Shows data coordinates under the mouse pointer (x, y).</div>
  </div>

  <div class="block tiny">
    Route color: <span class="pill">blue</span> · Result overlay: <span class="pill">red</span>
  </div>
</aside>

<main id="main">
  <div id="plots">
    <div id="plot3d" class="plot active"></div>
    <div id="plot2d" class="plot"></div>
  </div>
</main>
</div>

<script>
function safeStr(v){return (typeof v==="string")?v:(typeof v==="number"?String(v):"");}
function deepFind(obj,predicate,maxDepth=6){
  const out=[],seen=new Set(),stack=[{v:obj,d:0}];
  while(stack.length){
    const {v,d}=stack.pop();
    if(!v||typeof v!=="object")continue;
    if(seen.has(v))continue; seen.add(v);
    if(predicate(v))out.push(v);
    if(d>=maxDepth)continue;
    if(Array.isArray(v)) for(let i=v.length-1;i>=0;i--) stack.push({v:v[i],d:d+1});
    else for(const k of Object.keys(v)) stack.push({v:v[k],d:d+1});
  }
  return out;
}
function iterCellSpaces(obj){
  const out=[];
  if(!obj||typeof obj!=="object") return out;
  if(Array.isArray(obj.cellSpaceMember)) out.push(...obj.cellSpaceMember);
  if(Array.isArray(obj?.primalSpace?.cellSpaceMember)) out.push(...obj.primalSpace.cellSpaceMember);
  const indoorFeatures=obj.indoorFeatures||obj.IndoorFeatures||null;
  const thematicLayer=indoorFeatures?.layers||null;
  if(Array.isArray(thematicLayer)){
    for(const tl of thematicLayer){
      if(Array.isArray(tl?.primalSpace?.cellSpaceMember)) out.push(...tl.primalSpace.cellSpaceMember);
      const primal=tl?.primalSpace||null;
      const members=primal?.cellSpaceMember||null;
      if(Array.isArray(members)) out.push(...members);
    }
  }
  if(Array.isArray(obj.layers)){
    for(const layer of obj.layers){
      const primal=layer?.primalSpace||layer?.primalSpaceLayer||layer?.primal||null;
      const members=primal?.cellSpaceMember||primal?.cellSpaces||primal?.cellspaceMember||null;
      if(Array.isArray(members)) out.push(...members);
    }
  }
  const seen=new Set(),dedup=[];
  for(const cs of out){const id=cs?.id?String(cs.id):null; if(id&&seen.has(id)) continue; if(id) seen.add(id); dedup.push(cs);}
  return dedup;
}
function iterDualNodes(obj){
  const out=[];
  if(!obj||typeof obj!=="object") return out;

  const pushMembers = (dual)=>{
    if(!dual) return;
    const members = dual.nodeMember ||  null;
    if(Array.isArray(members)){
      for(const it of members){
        if(Array.isArray(it)) out.push(...it);
        else out.push(it);
      }
    }
  };

  // A) direct: obj.dualSpace
  pushMembers(obj.dualSpace||null);

  // B) obj.layers[].dualSpace
  if(Array.isArray(obj.layers)){
    for(const layer of obj.layers){
      pushMembers(layer?.dualSpace||null);
    }
  }

  // C) IndoorFeatures schema: obj.indoorFeatures.layers[].dualSpace  (your PNU-201 style)
  const IF = obj.indoorFeatures || obj.indoorFeature || obj.IndoorFeatures || null;
  if(IF){
    if(Array.isArray(IF.layers)){
      for(const layer of IF.layers){
        pushMembers(layer?.dualSpace||null);
      }
    }
  }

  // Dedup by id
  const seen=new Set(), dedup=[];
  for(const n of out){
    const id = n && (n.id||n.identifier||n.nodeId);
    if(!id) continue;
    const key=String(id);
    if(seen.has(key)) continue;
    seen.add(key);
    dedup.push(n);
  }
  return dedup;
}
function iterDualNodes(obj){
  const out=[];
  if(!obj||typeof obj!=="object") return out;

  const pushMembers = (dual)=>{
    if(!dual) return;
    const members = dual.nodeMember ||  null;
    if(Array.isArray(members)){
      for(const it of members){
        if(Array.isArray(it)) out.push(...it);
        else out.push(it);
      }
    }
  };

  // A) direct: obj.dualSpace
  pushMembers(obj.dualSpace||null);

  // B) obj.layers[].dualSpace
  if(Array.isArray(obj.layers)){
    for(const layer of obj.layers){
      pushMembers(layer?.dualSpace||null);
    }
  }

  // C) IndoorFeatures schema: obj.indoorFeatures.layers[].dualSpace  (your PNU-201 style)
  const IF = obj.indoorFeatures || obj.indoorFeature || obj.IndoorFeatures || null;
  if(IF){
    if(Array.isArray(IF.layers)){
      for(const layer of IF.layers){
        pushMembers(layer?.dualSpace||null);
      }
    }
  }

  // Dedup by id
  const seen=new Set(), dedup=[];
  for(const n of out){
    const id = n && (n.id||n.identifier||n.nodeId);
    if(!id) continue;
    const key=String(id);
    if(seen.has(key)) continue;
    seen.add(key);
    dedup.push(n);
  }
  return dedup;
}

function iterDualEdges(obj){
  const out=[];
  if(!obj||typeof obj!=="object") return out;

  const pushMembers = (dual)=>{
    if(!dual) return;
    const members = dual.edgeMember || null;
    if(Array.isArray(members)){
      for(const it of members){
        if(Array.isArray(it)) out.push(...it);
        else out.push(it);
      }
    }
  };

  // A) direct: obj.dualSpace
  pushMembers(obj.dualSpace||null);

  // B) obj.layers[].dualSpace
  if(Array.isArray(obj.layers)){
    for(const layer of obj.layers){
      pushMembers(layer?.dualSpace||null);
    }
  }

  // C) IndoorFeatures schema: obj.indoorFeatures.layers[].dualSpace
  const IF = obj.indoorFeatures || obj.indoorFeature || obj.IndoorFeatures || null;
  if(IF){
    if(Array.isArray(IF.layers)){
      for(const layer of IF.layers){
        pushMembers(layer?.dualSpace||layer?.dual||layer?.dualSpaceLayer||null);
      }
    }
  }

  // Dedup by id
  const seen=new Set(), dedup=[];
  for(const e of out){
    const id = e && (e.id||e.identifier||e.edgeId);
    if(!id) continue;
    const key=String(id);
    if(seen.has(key)) continue;
    seen.add(key);
    dedup.push(e);
  }
  return dedup;
}
function extractDualGraph(obj){
  const nodeMap=new Map(), edgeMap=new Map();
  const nodeObjs=deepFind(obj, v=>v&&typeof v==="object"&&v.featureType==="Node"&&v.geometry?.type==="Point"&&Array.isArray(v.geometry?.coordinates), 9);
  for(const n of nodeObjs) if(n.id) nodeMap.set(String(n.id), n.geometry.coordinates);
  const edgeObjs=deepFind(obj, v=>v&&typeof v==="object"&&v.featureType==="Edge"&&v.geometry?.type==="LineString"&&Array.isArray(v.geometry?.coordinates), 9);
  for(const e of edgeObjs) if(e.id) edgeMap.set(String(e.id), e.geometry.coordinates);
  return {nodeMap, edgeMap};
}
function triangulateRing(pts){
  // Triangulate a single 3D ring (face boundary) robustly:
  // 1) compute face plane basis (u,v)
  // 2) project to 2D
  // 3) earcut triangulation
  // 4) map back to 3D triangles
  if(!Array.isArray(pts)||pts.length<3) return [];
  // drop closure point if present
  const first=pts[0], last=pts[pts.length-1];
  if(first&&last&&first[0]===last[0]&&first[1]===last[1]&&((first[2]??0)===(last[2]??0))) pts=pts.slice(0,-1);
  if(pts.length<3) return [];

  // find a stable normal using first non-collinear triple
  let n=null, p0=null;
  for(let a=0;a<pts.length-2 && !n;a++){
    for(let b=a+1;b<pts.length-1 && !n;b++){
      for(let c=b+1;c<pts.length && !n;c++){
        const A=pts[a], B=pts[b], C=pts[c];
        const ab=[B[0]-A[0], B[1]-A[1], (B[2]??0)-(A[2]??0)];
        const ac=[C[0]-A[0], C[1]-A[1], (C[2]??0)-(A[2]??0)];
        const cross=[ab[1]*ac[2]-ab[2]*ac[1], ab[2]*ac[0]-ab[0]*ac[2], ab[0]*ac[1]-ab[1]*ac[0]];
        const len=Math.hypot(cross[0],cross[1],cross[2]);
        if(len>1e-9){ n=[cross[0]/len,cross[1]/len,cross[2]/len]; p0=A; }
      }
    }
  }
  if(!n){
    // degenerate (collinear) -> fallback fan
    const tris=[];
    for(let i=1;i<pts.length-1;i++) tris.push([pts[0],pts[i],pts[i+1]]);
    return tris;
  }

  // build orthonormal basis u,v on face plane
  // choose any vector not parallel to n
  const ref = (Math.abs(n[2])<0.9) ? [0,0,1] : [0,1,0];
  let u=[n[1]*ref[2]-n[2]*ref[1], n[2]*ref[0]-n[0]*ref[2], n[0]*ref[1]-n[1]*ref[0]];
  let ulen=Math.hypot(u[0],u[1],u[2]);
  if(ulen<1e-9){
    // try different ref
    const ref2=[1,0,0];
    u=[n[1]*ref2[2]-n[2]*ref2[1], n[2]*ref2[0]-n[0]*ref2[2], n[0]*ref2[1]-n[1]*ref2[0]];
    ulen=Math.hypot(u[0],u[1],u[2]);
  }
  u=[u[0]/ulen,u[1]/ulen,u[2]/ulen];
  const v=[n[1]*u[2]-n[2]*u[1], n[2]*u[0]-n[0]*u[2], n[0]*u[1]-n[1]*u[0]];

  // project to 2D for earcut
  const coords2d=[];
  for(const P of pts){
    const px=P[0]-p0[0], py=P[1]-p0[1], pz=(P[2]??0)-(p0[2]??0);
    const x2=px*u[0]+py*u[1]+pz*u[2];
    const y2=px*v[0]+py*v[1]+pz*v[2];
    coords2d.push(x2,y2);
  }

  if(typeof earcut!=="function"){
    // earcut missing -> fallback fan
    const tris=[];
    for(let i=1;i<pts.length-1;i++) tris.push([pts[0],pts[i],pts[i+1]]);
    return tris;
  }

  const idx=earcut(coords2d, null, 2);
  const tris=[];
  for(let t=0;t<idx.length;t+=3){
    tris.push([pts[idx[t]], pts[idx[t+1]], pts[idx[t+2]]]);
  }
  return tris;
}
function polyhedronToTris(geom3d){
  const tris=[], coords=geom3d?.coordinates;
  if(!Array.isArray(coords)) return tris;
  const polys=looksLikeFaceList(coords)?[coords]:coords;
  for(const poly of polys){
    if(!Array.isArray(poly)) continue;
    for(const face of poly){
      if(!face) continue;
      let ring=face;
      if(Array.isArray(face)&&Array.isArray(face[0])&&Array.isArray(face[0][0])) ring=face[0];
      if(!Array.isArray(ring)||ring.length<3) continue;
      const pts=ring.map(p=>[p[0],p[1],p[2]??0]);
      tris.push(...triangulateRing(pts));
    }
  }
  return tris;
  function looksLikeFaceList(c){
    if(!Array.isArray(c)||!c.length) return false;
    const a=c[0]; if(!Array.isArray(a)||!a.length) return false;
    const b=a[0]; return Array.isArray(b)&&typeof b[0]==="number";
  }
}
function polygon2dToRings(geom2d){
  const type=geom2d?.type, coords=geom2d?.coordinates, rings=[];
  if(!coords) return rings;
  if(type==="Polygon"){ if(Array.isArray(coords[0])) rings.push(coords[0]); }
  else if(type==="MultiPolygon"){ for(const poly of coords) if(Array.isArray(poly?.[0])) rings.push(poly[0]); }
  return rings;
}
function bboxFromPoints(points){
  let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
  for(const p of points){
    const x=p[0],y=p[1],z=p[2]??0;
    if(!Number.isFinite(x)||!Number.isFinite(y)||!Number.isFinite(z)) continue;
    minX=Math.min(minX,x); minY=Math.min(minY,y); minZ=Math.min(minZ,z);
    maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); maxZ=Math.max(maxZ,z);
  }
  if(!Number.isFinite(minX)) return null;
  return {min:[minX,minY,minZ], max:[maxX,maxY,maxZ]};
}
let MODEL=null, GRAPH=null, RESULT2D=null, ROUTE=null;
let CURRENT_LEVEL="__all__", CURRENT_MODE="3d";
let SHOW_RESULT=true, SHOW_ROUTE=true;
let ROUTE_STITCH=false;
let LAST_ROUTE_JSON=null;
let ROUTE_SEGMENTS=[];
let SHOW_SEG_MARKERS=true;
let SHOW_SEG_LABELS=false;
let SHOW_DUAL=false;

function buildBaseModel(indoorjson){
  const cells=iterCellSpaces(indoorjson);
  const levels=new Set(), byLevel3d=new Map(), byLevel2d=new Map();
  const addLevel=(lvl)=>{levels.add(lvl); if(!byLevel3d.has(lvl)) byLevel3d.set(lvl,{x:[],y:[],z:[],i:[],j:[],k:[]}); if(!byLevel2d.has(lvl)) byLevel2d.set(lvl,{pairs:[]});};
  for(const cs of cells){
    const lvl=safeStr(cs.level)||safeStr(cs.storey)||safeStr(cs.properties?.level)||"UNKNOWN";
    addLevel(lvl);
    const geom=cs.cellSpaceGeom||cs.cellspaceGeom||cs.CellSpaceGeom||{};
    const g3=geom.geometry3D||geom.Geometry3D||null;
    const g2=geom.geometry2D||geom.Geometry2D||null;

    if(g3&&g3.type==="Polyhedron"){
      const tris=polyhedronToTris(g3), store=byLevel3d.get(lvl);
      for(const tri of tris){
        const base=store.x.length;
        for(const p of tri){store.x.push(p[0]);store.y.push(p[1]);store.z.push(p[2]??0);}
        store.i.push(base);store.j.push(base+1);store.k.push(base+2);
      }
    }
    const store2=byLevel2d.get(lvl);
    if(g2&&(g2.type==="Polygon"||g2.type==="MultiPolygon")){
      const rings=polygon2dToRings(g2);
      for(const ring of rings) pushRingPairs(store2.pairs, ring);
    } else if(g3&&g3.type==="Polyhedron"){
      const tris=polyhedronToTris(g3), pts=[];
      for(const tri of tris) for(const p of tri) pts.push(p);
      const bb=bboxFromPoints(pts);
      if(bb){
        const x0=bb.min[0],y0=bb.min[1],x1=bb.max[0],y1=bb.max[1];
        pushRingPairs(store2.pairs, [[x0,y0],[x1,y0],[x1,y1],[x0,y1],[x0,y0]]);
      }
    }
  }
  const dualNodes=iterDualNodes(indoorjson).filter(n=>n?.geometry?.type==="Point"&&Array.isArray(n.geometry?.coordinates));
  const dualEdges=iterDualEdges(indoorjson).filter(e=>e?.geometry?.type==="LineString"&&Array.isArray(e.geometry?.coordinates));


  return {levels:Array.from(levels).sort(), byLevel3d, byLevel2d, dualNodes, dualEdges};
  function pushRingPairs(pairs, ring){
    if(!Array.isArray(ring)||ring.length<2) return;
    const pts=ring.slice(); const a=pts[0], b=pts[pts.length-1];
    if(!(a[0]===b[0]&&a[1]===b[1])) pts.push(a);
    for(const p of pts) pairs.push([p[0],p[1]]);
    pairs.push([null,null]);
  }
}

function buildOverlayModel(obj){
  const byLevel2d=new Map(), levels=new Set(); let count=0;
  const addLevel=(lvl)=>{levels.add(lvl); if(!byLevel2d.has(lvl)) byLevel2d.set(lvl,{pairs:[],count:0});};

  const feats=toGeoFeatures(obj);
  if(feats.length){
    for(const f of feats){
      const props=f.properties||{};
      const lvl=safeStr(props.level)||safeStr(props.storey)||safeStr(props.floor)||"__all__";
      addLevel(lvl);
      const store=byLevel2d.get(lvl);
      addGeometryPairs(store.pairs, f.geometry||f);
      store.count++; count++;
    }
    return {levels:Array.from(levels).sort(), byLevel2d, count, format:"geojson"};
  }
  const cells=iterCellSpaces(obj);
  if(cells.length){
    for(const cs of cells){
      const lvl=safeStr(cs.level)||safeStr(cs.storey)||safeStr(cs.properties?.level)||"UNKNOWN";
      const g2=cs?.cellSpaceGeom?.geometry2D||cs?.cellSpaceGeom?.Geometry2D||null;
      if(!g2||!g2.type) continue;
      addLevel(lvl);
      const store=byLevel2d.get(lvl);
      if(g2.type==="Polygon"||g2.type==="MultiPolygon"){
        const rings=polygon2dToRings(g2);
        for(const ring of rings) pushRingPairs(store.pairs, ring);
      } else addGeometryPairs(store.pairs, g2);
      store.count++; count++;
    }
    return {levels:Array.from(levels).sort(), byLevel2d, count, format:"indoorjson"};
  }
  return {levels:[], byLevel2d, count:0, format:"unknown"};

  function toGeoFeatures(o){
    if(!o||typeof o!=="object") return [];
    if(o.type==="FeatureCollection"&&Array.isArray(o.features)) return o.features;
    if(o.type==="Feature") return [o];
    if(typeof o.type==="string"&&o.coordinates) return [{type:"Feature",properties:{},geometry:o}];
    if(Array.isArray(o)) return o.flatMap(toGeoFeatures);
    return [];
  }
  function addGeometryPairs(pairs, geom){
    if(!geom||typeof geom!=="object") return;
    const t=geom.type, c=geom.coordinates;
    if(t==="Polygon"){ if(Array.isArray(c?.[0])) pushRingPairs(pairs,c[0]); return; }
    if(t==="MultiPolygon"){ for(const poly of c||[]) if(Array.isArray(poly?.[0])) pushRingPairs(pairs, poly[0]); return; }
    if(t==="LineString"){ pushLinePairs(pairs,c); return; }
    if(t==="MultiLineString"){ for(const line of c||[]) pushLinePairs(pairs,line); return; }
    if(t==="GeometryCollection"){ for(const g of geom.geometries||[]) addGeometryPairs(pairs,g); return; }
    if(Array.isArray(c)) pushLinePairs(pairs, flattenPoints(c));
  }
  function pushRingPairs(pairs, ring){
    if(!Array.isArray(ring)||ring.length<2) return;
    const pts=ring.slice(); const a=pts[0], b=pts[pts.length-1];
    if(!(a[0]===b[0]&&a[1]===b[1])) pts.push(a);
    for(const p of pts) pairs.push([p[0],p[1]]);
    pairs.push([null,null]);
  }
  function pushLinePairs(pairs, line){
    if(!Array.isArray(line)||line.length<2) return;
    for(const p of line) pairs.push([p[0],p[1]]);
    pairs.push([null,null]);
  }
  function flattenPoints(any){
    const out=[], stack=[any];
    while(stack.length){
      const cur=stack.pop();
      if(!cur) continue;
      if(Array.isArray(cur)&&typeof cur[0]==="number"){ out.push(cur); continue; }
      if(Array.isArray(cur)) for(const v of cur) stack.push(v);
    }
    return out.reverse();
  }
}

function buildRoute(obj, graph, stitch){
  // returns {points:[[x,y,z] or null breaks], source:"...", count:int, segments:[...]}
  // stitch=false: trust route order/direction (directed graph outputs)
  // stitch=true: auto-orient segments + insert breaks (good for undirected/unordered)

  // 1) Your API: {type:"RouteResult", path_segments:[{geometry:{...}}, ...]}
  if (obj && typeof obj === "object" && (obj.type === "RouteResult" || obj.type === "IndoorRouteResult") && Array.isArray(obj.path_segments)) {
    const segments = [];
    const normPt = (p) => [p[0], p[1], (p.length>=3 ? p[2] : 0)];

    if (!stitch) {
      const pts = [];
      for (const seg of obj.path_segments){
        const g = seg?.geometry;
        if (!g || !g.type || !Array.isArray(g.coordinates)) continue;

        let segPts = [];
        if (g.type === "LineString") segPts = g.coordinates.map(normPt);
        else if (g.type === "MultiLineString") segPts = g.coordinates.flat().map(normPt);
        else if (g.type === "Point") segPts = [normPt(g.coordinates)];
        else if (g.type === "MultiPoint") segPts = g.coordinates.map(normPt);
        else continue;

        if (!segPts.length) continue;
        pts.push(...segPts);

        segments.push({
          seq: seg?.seq ?? null,
          id_str: seg?.id_str ?? null,
          type: seg?.type ?? null,
          cost: seg?.cost ?? null,
          start: segPts[0],
          end: segPts[segPts.length-1]
        });
      }
      if (pts.length) return {points: pts, segments, source:"RouteResult.path_segments", count: pts.length};
    } else {
      const pts = [];
      let cursor = null;
      const EPS = 1e-6;

      const dist2 = (a,b) => {
        const dx=(a[0]-b[0]), dy=(a[1]-b[1]), dz=((a[2]??0)-(b[2]??0));
        return dx*dx+dy*dy+dz*dz;
      };
      const same = (a,b) => dist2(a,b) <= EPS;

      const pushBreak = () => {
        if (pts.length && (pts[pts.length-1][0] !== null)) pts.push([null,null,null]);
        cursor = null;
      };

      for (const seg of obj.path_segments){
        const g = seg?.geometry;
        if (!g || !g.type || !Array.isArray(g.coordinates)) continue;

        let segPts = [];
        if (g.type === "LineString") segPts = g.coordinates.slice();
        else if (g.type === "MultiLineString") segPts = g.coordinates.flat();
        else if (g.type === "Point") segPts = [g.coordinates];
        else if (g.type === "MultiPoint") segPts = g.coordinates.slice();
        else continue;

        if (!segPts.length) continue;
        segPts = segPts.map(normPt);

        if (segPts.length >= 2 && cursor) {
          const dStart = dist2(cursor, segPts[0]);
          const dEnd   = dist2(cursor, segPts[segPts.length-1]);
          if (dEnd < dStart) segPts.reverse();
        }

        if (cursor && !same(cursor, segPts[0])) pushBreak();
        if (cursor && same(cursor, segPts[0])) segPts = segPts.slice(1);
        if (!segPts.length) continue;

        const segStart = segPts[0];
        const segEnd = segPts[segPts.length-1];

        for (const p of segPts) pts.push(p);

        segments.push({
          seq: seg?.seq ?? null,
          id_str: seg?.id_str ?? null,
          type: seg?.type ?? null,
          cost: seg?.cost ?? null,
          start: segStart,
          end: segEnd
        });

        cursor = pts.length ? pts[pts.length-1] : null;
        if (cursor && cursor[0] === null) cursor = null;
      }

      while (pts.length && pts[pts.length-1][0] === null) pts.pop();
      const count = pts.filter(p=>p[0]!==null).length;
      if (count) return {points: pts, segments, source:"RouteResult.path_segments(stitched)", count};
    }
    return {points: [], segments: [], source:"RouteResult(empty)", count: 0};
  }

  // 2) GeoJSON LineString / MultiLineString
  const feats=toGeoLineFeatures(obj);
  if(feats.length){
    const pts=[];
    for(const f of feats){
      const g=f.geometry||f;
      if(g.type==="LineString") pts.push(...g.coordinates);
      else if(g.type==="MultiLineString") for(const line of g.coordinates) pts.push(...line);
    }
    const norm=normalizePts(pts);
    return {points:norm, segments: [], source:"geojson", count:norm.length};
  }

  // 3) Any object with a coordinates array (common wrapper)
  const coords=findCoords(obj);
  if(coords){
    const norm=normalizePts(flattenToPoints(coords));
    if(norm.length) return {points:norm, segments: [], source:"coordinates", count:norm.length};
  }

  // 4) nodeIds / nodes
  const nodeIds=findIdArray(obj,["nodeIds","nodes","node_id_list","node_id"]);
  if(nodeIds&&graph?.nodeMap){
    const pts=nodeIds.map(id=>graph.nodeMap.get(String(id))).filter(Boolean);
    const norm=normalizePts(pts);
    if(norm.length) return {points:norm, segments: [], source:"nodeIds", count:norm.length};
  }

  // Also support start_node/destination_node as strings: draw a 2-point line
  if(obj && typeof obj==="object" && graph?.nodeMap && (typeof obj.start_node==="string" || typeof obj.destination_node==="string")){
    const a = (typeof obj.start_node==="string") ? graph.nodeMap.get(String(obj.start_node)) : null;
    const b = (typeof obj.destination_node==="string") ? graph.nodeMap.get(String(obj.destination_node)) : null;
    const pts = [];
    if (a) pts.push(a);
    if (b) pts.push(b);
    const norm = normalizePts(pts);
    if (norm.length>=2) return {points:norm, segments: [], source:"start_node/destination_node", count:norm.length};
  }

  // 5) edgeIds / edges
  const edgeIds=findIdArray(obj,["edgeIds","edges","edge_id_list","edge_id"]);
  if(edgeIds&&graph?.edgeMap){
    const pts=[];
    for(const id of edgeIds){
      const line=graph.edgeMap.get(String(id));
      if(Array.isArray(line)) pts.push(...line);
    }
    const norm=normalizePts(pts);
    if(norm.length) return {points:norm, segments: [], source:"edgeIds", count:norm.length};
  }

  // 6) fallback: any embedded LineString/MultiLineString
  const anyLines=deepFind(obj,v=>v&&typeof v==="object"&&(v.type==="LineString"||v.type==="MultiLineString")&&Array.isArray(v.coordinates),7);
  if(anyLines.length){
    const pts=[];
    for(const g of anyLines){
      if(g.type==="LineString") pts.push(...g.coordinates);
      else for(const line of g.coordinates) pts.push(...line);
    }
    const norm=normalizePts(pts);
    if(norm.length) return {points:norm, segments: [], source:"embedded-linestring", count:norm.length};
  }

  return {points:[], segments: [], source:"unknown", count:0};

  function toGeoLineFeatures(o){
    return toGeoFeatures(o).filter(f=>{
      const g=f.geometry||f;
      return g&&(g.type==="LineString"||g.type==="MultiLineString")&&Array.isArray(g.coordinates);
    });
  }
  function toGeoFeatures(o){
    if(!o||typeof o!=="object") return [];
    if(o.type==="FeatureCollection"&&Array.isArray(o.features)) return o.features;
    if(o.type==="Feature") return [o];
    if(typeof o.type==="string"&&o.coordinates) return [{type:"Feature",properties:{},geometry:o}];
    if(Array.isArray(o)) return o.flatMap(toGeoFeatures);
    return [];
  }
  function normalizePts(pts){ return (pts||[]).map(p=>[p[0],p[1],(p.length>=3?p[2]:0)]); }
  function findCoords(o){
    if(!o||typeof o!=="object") return null;
    if(Array.isArray(o.coordinates)) return o.coordinates;
    for(const k of ["path","route","geometry","geom","result","data"]){
      const v=o[k];
      if(v&&typeof v==="object"&&Array.isArray(v.coordinates)) return v.coordinates;
    }
    const hits=deepFind(o,v=>Array.isArray(v?.coordinates),6);
    return hits.length?hits[0].coordinates:null;
  }
  function flattenToPoints(any){
    const pts=[], stack=[any];
    while(stack.length){
      const cur=stack.pop();
      if(!cur) continue;
      if(Array.isArray(cur)&&cur.length>=2&&typeof cur[0]==="number"){ pts.push(cur); continue; }
      if(Array.isArray(cur)) for(const v of cur) stack.push(v);
    }
    return pts.reverse();
  }
  function findIdArray(o, keys){
    if(!o||typeof o!=="object") return null;
    for(const k of keys){ const v=o[k]; if(Array.isArray(v)&&v.every(x=>typeof x==="string"||typeof x==="number")) return v; }
    const hits=deepFind(o,v=>keys.some(k=>Array.isArray(v?.[k])),5);
    if(hits.length){
      for(const h of hits){
        for(const k of keys){
          const v=h[k];
          if(Array.isArray(v)&&v.every(x=>typeof x==="string"||typeof x==="number")) return v;
        }
      }
    }
    return null;
  }
}

function renderAll(){
  if(!MODEL) return;
  const sel=document.getElementById("level");
  const prev=sel.value||"__all__";
  sel.innerHTML="";
  const all=document.createElement("option"); all.value="__all__"; all.textContent="All"; sel.appendChild(all);
  for(const lvl of MODEL.levels){ const o=document.createElement("option"); o.value=lvl; o.textContent=lvl; sel.appendChild(o); }
  sel.value=(MODEL.levels.includes(prev)||prev==="__all__")?prev:"__all__";
  CURRENT_LEVEL=sel.value;
  render3D(); render2D(); applyLevelFilter();
}
function render3D(){
  const traces=[];
  for(const lvl of MODEL.levels){
    const s=MODEL.byLevel3d.get(lvl);
    if(!s||!s.i.length) continue;
    traces.push({type:"mesh3d",name:lvl,x:s.x,y:s.y,z:s.z,i:s.i,j:s.j,k:s.k,opacity:0.45,hoverinfo:"skip",visible:(CURRENT_LEVEL==="__all__"||CURRENT_LEVEL===lvl),meta:{role:"base",level:lvl}});
  }
  // Dual graph (3D) nodes/edges (Z-filtered by the selected level's base geometry)
  if (SHOW_DUAL){
    let zMin=-Infinity, zMax=Infinity;
    if (CURRENT_LEVEL !== "__all__"){
      const base = MODEL.byLevel3d?.get?.(CURRENT_LEVEL);
      if (base && Array.isArray(base.z) && base.z.length){
        zMin = Math.min(...base.z.filter(v=>v!==null && v!==undefined));
        zMax = Math.max(...base.z.filter(v=>v!==null && v!==undefined));
        // small padding to be tolerant to float jitter
        const pad = Math.max(1e-6, (zMax - zMin) * 0.01);
        // zMin -= pad; // zMax += pad; 
      }
    }

    // Edges
    // We'll instead use precomputed arrays if present
    const dualEdges = MODEL.dualEdges || null;

    const ex=[], ey=[], ez=[];
    const pushBreak = ()=>{ ex.push(null); ey.push(null); ez.push(null); };

    const addCoords = (coords)=>{
      let drawing=false;
      let ox; let oy; let oz;
      for(const c of coords){
        const x=c[0], y=c[1], z=(c.length>=3?c[2]:0);
        const inside = (z>=zMin && z<zMax);
        const vertical = (z>=zMin && z<=zMax);
        if(inside){
          ex.push(x); ey.push(y); ez.push(z);
          drawing=true;
          ox=x; oy=y; oz=z;
        } else if(vertical && oz>=zMin && oz<zMax) {
          ex.push(x); ey.push(y); ez.push(z);
          drawing=true;
        } else{
          if(drawing){ pushBreak(); } drawing=false;
        }
      }
      if(drawing) pushBreak();
    };

    if (dualEdges && Array.isArray(dualEdges)){
      for(const e of dualEdges){
        const coords = e?.geometry?.coordinates;
        if(Array.isArray(coords) && coords.length) addCoords(coords);
      }
    } else {
      // fallback: use iterDualEdges on the loaded IndoorJSON (requires MODEL._src set; see buildBaseModel patch below)
      for(const e of iterDualEdges(MODEL._src || {}) ){
        const coords = e?.geometry?.coordinates;
        if(Array.isArray(coords) && coords.length) addCoords(coords);
      }
    }

    if(ex.length){
      traces.push({type:"scatter3d",mode:"lines",name:"DUAL_EDGES",x:ex,y:ey,z:ez,
        line:{width:4,color:"rgba(255,120,0,0.9)"},hoverinfo:"skip",
        visible:(CURRENT_MODE==="3d"),meta:{role:"dual"}});
    }

    // Nodes
    const nx=[], ny=[], nz=[], nhover=[];
    const dualNodes = MODEL.dualNodes ||  null;
    const addNodePt = (p, id, duality)=>{
      const z=(p.length>=3?p[2]:0);
      if(z<zMin || z>=zMax) return;
      nx.push(p[0]); ny.push(p[1]); nz.push(z);
      nhover.push(`Node ${id||""}${duality?` (duality ${duality})`:""}`);
    };

    if (dualNodes && Array.isArray(dualNodes)){
      for(const n of dualNodes){
        const p=n?.geometry?.coordinates;
        if(Array.isArray(p) && p.length>=2) addNodePt(p, n.id, n.duality);
      }
    } else {
      for(const n of iterDualNodes(MODEL._src || {}) ){
        const p=n?.geometry?.coordinates;
        if(Array.isArray(p) && p.length>=2) addNodePt(p, n.id, n.duality);
      }
    }

    if(nx.length){
      traces.push({type:"scatter3d",mode:"markers",name:"DUAL_NODES",x:nx,y:ny,z:nz,
        marker:{size:4,color:"rgba(128,0,128,1.0)"},hovertext:nhover,hoverinfo:"text",
        visible:(CURRENT_MODE==="3d"),meta:{role:"dual"}});
    }
  }
  if(ROUTE&&ROUTE.points&&ROUTE.points.length>=2){
    const xs=ROUTE.points.map(p=>p[0]), ys=ROUTE.points.map(p=>p[1]), zs=ROUTE.points.map(p=>p[2]);
    var nodeColors = [];
    for (var i = 0; i < xs.length; i++) {
      if (i === 0) {
          nodeColors.push("green");           // First Node (Start)
      } else if (i === xs.length - 1) {
          nodeColors.push("red");         // Last Node (Destination)
      } else {
          nodeColors.push("rgba(0,90,255,0.5)"); // Middle Nodes (Path)
      }
    }
    traces.push({type:"scatter3d",mode:"lines+markers",name:"ROUTE",x:xs,y:ys,z:zs,line:{width:6,color:"rgba(0,90,255,0.95)"},marker:{size:3,color:nodeColors},hoverinfo:"skip",visible:SHOW_ROUTE,meta:{role:"route",level:"__all__"}});
  // Segment boundaries (3D)
  if (SHOW_SEG_MARKERS && ROUTE_SEGMENTS && ROUTE_SEGMENTS.length){
    const bx=[], by=[], bz=[], hover=[], text=[];
    for(const s of ROUTE_SEGMENTS){
      const p=s.start; if(!p||p[0]===null) continue;
      bx.push(p[0]); by.push(p[1]); bz.push(p[2]??0);
      hover.push(`seq=${s.seq??""} id=${s.id_str??""} type=${s.type??""} cost=${s.cost??""}`);
      text.push(String(s.seq??""));
    }
    traces.push({type:"scatter3d",mode:SHOW_SEG_LABELS?"markers+text":"markers",name:"SEGMENTS",x:bx,y:by,z:bz,
      marker:{size:3,color:"rgba(255,140,0,0.95)"},
      text:SHOW_SEG_LABELS?text:undefined,textposition:"top center",
      hovertext:hover,hoverinfo:"text",visible:SHOW_ROUTE,meta:{role:"route",level:"__all__"}});
  }

  }
  Plotly.newPlot("plot3d",traces,{margin:{l:0,r:0,t:30,b:0},title:{text:"IndoorJSON (3D) + Route",x:0.02,y:0.98,xanchor:"left"},scene:{aspectmode:"data"},showlegend:false},{responsive:true});
}
function render2D(){
  const traces=[];
  for(const lvl of MODEL.levels){
    const s=MODEL.byLevel2d.get(lvl); if(!s||!s.pairs.length) continue;
    const xs=[],ys=[]; for(const p of s.pairs){xs.push(p[0]);ys.push(p[1]);}
    traces.push({type:"scattergl",mode:"lines",name:lvl,x:xs,y:ys,line:{width:1,color:"rgba(0,0,0,0.55)"},hoverinfo:"skip",visible:(CURRENT_LEVEL==="__all__"||CURRENT_LEVEL===lvl),meta:{role:"base",level:lvl}});
  }
  if(RESULT2D&&RESULT2D.levels.length){
    for(const lvl of RESULT2D.levels){
      const s=RESULT2D.byLevel2d.get(lvl); if(!s||!s.pairs.length) continue;
      const xs=[],ys=[]; for(const p of s.pairs){xs.push(p[0]);ys.push(p[1]);}
      traces.push({type:"scattergl",mode:"lines",name:(lvl==="__all__")?"RESULT":`RESULT:${lvl}`,x:xs,y:ys,line:{width:3,color:"rgba(220,0,0,0.95)"},hoverinfo:"skip",visible:SHOW_RESULT&&(CURRENT_LEVEL==="__all__"||lvl==="__all__"||lvl===CURRENT_LEVEL),meta:{role:"result",level:lvl}});
    }
  }
  if (SHOW_DUAL && MODEL.dualByLevelNodes){
    for(const [lvl, b] of MODEL.dualByLevelNodes.entries()){
      if(!b.x.length) continue;
      traces.push({type:"scattergl",mode:"markers",name:`DUAL_NODES_${lvl}`,x:b.x,y:b.y,
        marker:{size:7,color:"rgba(255,120,0,0.95)"},hovertext:b.hover,hoverinfo:"text",
        visible:(CURRENT_LEVEL==="__all__"||lvl==="__all__"||CURRENT_LEVEL===lvl),
        meta:{role:"dual",level:lvl}});
    }
  }
  if(ROUTE&&ROUTE.points&&ROUTE.points.length>=2){
    const xs=ROUTE.points.map(p=>p[0]).concat([null]);
    const ys=ROUTE.points.map(p=>p[1]).concat([null]);
    traces.push({type:"scattergl",mode:"lines+markers",name:"ROUTE",x:xs,y:ys,line:{width:4,color:"rgba(0,90,255,0.95)"},marker:{size:5,color:"rgba(0,90,255,0.95)"},hoverinfo:"skip",visible:SHOW_ROUTE,meta:{role:"route",level:"__all__"}});
  // Segment boundaries (2D)
  if (SHOW_SEG_MARKERS && ROUTE_SEGMENTS && ROUTE_SEGMENTS.length){
    const bx=[], by=[], hover=[], text=[];
    for(const s of ROUTE_SEGMENTS){
      const p=s.start; if(!p||p[0]===null) continue;
      bx.push(p[0]); by.push(p[1]);
      hover.push(`seq=${s.seq??""} id=${s.id_str??""} type=${s.type??""} cost=${s.cost??""}`);
      text.push(String(s.seq??""));
    }
    traces.push({type:"scattergl",mode:SHOW_SEG_LABELS?"markers+text":"markers",name:"SEGMENTS",x:bx,y:by,
      marker:{size:10,color:"rgba(255,140,0,0.95)"},
      text:SHOW_SEG_LABELS?text:undefined,textposition:"top center",
      hovertext:hover,hoverinfo:"text",visible:SHOW_ROUTE,meta:{role:"route",level:"__all__"}});
  }

  }
  Plotly.newPlot("plot2d",traces,{margin:{l:40,r:10,t:30,b:40},title:{text:"IndoorJSON (2D) + Overlay + Route",x:0.02,y:0.98,xanchor:"left"},xaxis:{scaleanchor:"y",zeroline:false},yaxis:{zeroline:false},showlegend:false},{responsive:true}).then(()=>{attachCursor2D();});
}
function applyLevelFilter(){
  if(!MODEL) return;

  const gd3=document.getElementById("plot3d");
  if(gd3&&gd3.data){
    Plotly.restyle(gd3,{visible:gd3.data.map(d=>{
      const role=d.meta?.role||"base";
      if(role==="base"){
        return (CURRENT_LEVEL==="__all__"||d.name===CURRENT_LEVEL);
      }
      if(role==="dual"){
        // Dual graph is 3D-only in this viewer; level filtering is handled by re-rendering (Z filtering).
        return (SHOW_DUAL && CURRENT_MODE==="3d");
      }
      if(role==="route") return SHOW_ROUTE;
      return true;
    })});
  }

  const gd2=document.getElementById("plot2d");
  if(gd2&&gd2.data){
    Plotly.restyle(gd2,{visible:gd2.data.map(d=>{
      const role=d.meta?.role||"base";
      const lvl=d.meta?.level||"__all__";
      if(role==="base"){
        return (CURRENT_LEVEL==="__all__"||d.name===CURRENT_LEVEL);
      }
      if(role==="result"){
        if(!SHOW_RESULT) return false;
        if(CURRENT_LEVEL==="__all__") return true;
        return (lvl==="__all__"||lvl===CURRENT_LEVEL);
      }
      if(role==="dual"){
        // Dual graph not shown in 2D.
        return false;
      }
      if(role==="route") return SHOW_ROUTE;
      return true;
    })});
  }
}
function fitView(){
  const gd=(CURRENT_MODE==="3d")?document.getElementById("plot3d"):document.getElementById("plot2d");
  if(!gd) return;
  if(CURRENT_MODE==="3d") Plotly.relayout(gd,{"scene.camera":null});
  else Plotly.relayout(gd,{"xaxis.autorange":true,"yaxis.autorange":true});
}

const fileInput=document.getElementById("file");
const fileResult=document.getElementById("fileResult");
const fileRoute=document.getElementById("fileRoute");
const statusEl=document.getElementById("status");
const statusResultEl=document.getElementById("statusResult");
const statusRouteEl=document.getElementById("statusRoute");
const selEl=document.getElementById("sel");
const cursorEl=document.getElementById("cursor");

document.getElementById("btn3d").addEventListener("click",()=>setMode("3d"));
document.getElementById("btn2d").addEventListener("click",()=>setMode("2d"));
document.getElementById("level").addEventListener("change",(e)=>{CURRENT_LEVEL=e.target.value;if(MODEL){render3D();render2D();applyLevelFilter();};});
document.getElementById("fit").addEventListener("click",fitView);
document.getElementById("reset").addEventListener("click",()=>{CURRENT_LEVEL="__all__";document.getElementById("level").value="__all__";applyLevelFilter();fitView();selEl.textContent="{}";});
document.getElementById("toggleResult").addEventListener("change",(e)=>{SHOW_RESULT=e.target.checked;applyLevelFilter();});
document.getElementById("toggleRoute").addEventListener("change",(e)=>{SHOW_ROUTE=e.target.checked;applyLevelFilter();});
document.getElementById("toggleSegMarkers").addEventListener("change",(e)=>{SHOW_SEG_MARKERS=e.target.checked;if(MODEL){render3D();render2D();applyLevelFilter();}});
document.getElementById("toggleSegLabels").addEventListener("change",(e)=>{SHOW_SEG_LABELS=e.target.checked;if(MODEL){render3D();render2D();applyLevelFilter();}});
document.getElementById("toggleDual").addEventListener("change",(e)=>{SHOW_DUAL=e.target.checked; if(MODEL){render3D();render2D();applyLevelFilter();}});
document.getElementById("toggleRouteStitch").addEventListener("change", (e) => {
  ROUTE_STITCH = e.target.checked;
  if (LAST_ROUTE_JSON) {
    ROUTE = buildRoute(LAST_ROUTE_JSON, GRAPH, ROUTE_STITCH);
    ROUTE_SEGMENTS = (ROUTE && ROUTE.segments) ? ROUTE.segments : [];
    if (MODEL) { render3D(); render2D(); applyLevelFilter(); }
  }
});
function setMode(mode){
  CURRENT_MODE=mode;
  document.getElementById("plot3d").classList.toggle("active",mode==="3d");
  document.getElementById("plot2d").classList.toggle("active",mode==="2d");
  document.getElementById("btn3d").classList.toggle("active",mode==="3d");
  document.getElementById("btn2d").classList.toggle("active",mode==="2d");
  fitView();
}

fileInput.addEventListener("change",async(e)=>{
  const file=e.target.files?.[0]; if(!file) return;
  statusEl.textContent=`Loading ${file.name}...`;
  try{
    const json=JSON.parse(await file.text());
    MODEL=buildBaseModel(json);
    GRAPH=extractDualGraph(json);
    statusEl.textContent=`Loaded ${file.name}. Levels: ${MODEL.levels.length}. Graph nodes: ${GRAPH.nodeMap.size}, edges: ${GRAPH.edgeMap.size}.`;
    renderAll();
  }catch(err){console.error(err); statusEl.textContent=`Failed to load: ${err?.message||err}`;}
});

fileResult.addEventListener("change",async(e)=>{
  const file=e.target.files?.[0]; if(!file) return;
  statusResultEl.textContent=`Loading ${file.name}...`;
  try{
    const json=JSON.parse(await file.text());
    RESULT2D=buildOverlayModel(json);
    if(RESULT2D.format==="unknown"||RESULT2D.count===0) statusResultEl.textContent=`Loaded ${file.name}, but couldn't find any 2D geometries to draw.`;
    else statusResultEl.textContent=`Loaded ${file.name}. Overlay: ${RESULT2D.format}. Items: ${RESULT2D.count}. Levels: ${RESULT2D.levels.length}.`;
    if(MODEL){render2D();applyLevelFilter();}
  }catch(err){console.error(err); statusResultEl.textContent=`Failed to load: ${err?.message||err}`;}
});

fileRoute.addEventListener("change",async(e)=>{
  const file=e.target.files?.[0]; if(!file) return;
  statusRouteEl.textContent=`Loading ${file.name}...`;
  try{
    const json=JSON.parse(await file.text());
    LAST_ROUTE_JSON = json;
    ROUTE = buildRoute(json, GRAPH, ROUTE_STITCH);
    ROUTE_SEGMENTS = (ROUTE && ROUTE.segments) ? ROUTE.segments : [];
    if(!ROUTE.points.length) statusRouteEl.textContent=`Loaded ${file.name}, but couldn't extract a route polyline.`;
    else statusRouteEl.textContent=`Loaded ${file.name}. Route source: ${ROUTE.source}. Points: ${ROUTE.points.length}.`;
    if(MODEL){render3D();render2D();applyLevelFilter();}
  }catch(err){console.error(err); statusRouteEl.textContent=`Failed to load: ${err?.message||err}`;}
});


function attachCursor2D(){
  // Live cursor readout for 2D plot (even when not hovering a trace)
  const gd2=document.getElementById("plot2d");
  if(!gd2 || !cursorEl) return;

  // Avoid stacking multiple listeners when re-rendering
  if(gd2.__cursorAttached) return;
  gd2.__cursorAttached = true;

  const fmt = (v)=> (Number.isFinite(v) ? (Math.abs(v) >= 1000 ? v.toFixed(0) : v.toFixed(3)) : "—");

  // 1) When hovering an actual drawn point/segment
  gd2.on?.("plotly_hover",(ev)=>{
    if(CURRENT_MODE!=="2d") return;
    const p=ev?.points?.[0];
    if(!p) return;
    cursorEl.textContent = `x: ${fmt(p.x)}\ny: ${fmt(p.y)}`;
  });
  gd2.on?.("plotly_unhover",()=>{
    if(CURRENT_MODE!=="2d") return;
    // leave last value; mousemove will update
  });

  // 2) When moving over empty space: convert screen px -> data coords using axis transforms
  gd2.addEventListener("mousemove",(e)=>{
    if(CURRENT_MODE!=="2d") return;
    if(!gd2._fullLayout || !gd2._fullLayout.xaxis || !gd2._fullLayout.yaxis) return;

    const rect = gd2.getBoundingClientRect();
    const xpx = e.clientX - rect.left;
    const ypx = e.clientY - rect.top;

    const xa = gd2._fullLayout.xaxis;
    const ya = gd2._fullLayout.yaxis;

    // Plot area bounds
    const x0 = xa._offset;
    const x1 = xa._offset + xa._length;
    const y0 = ya._offset;
    const y1 = ya._offset + ya._length;

    if(xpx < x0 || xpx > x1 || ypx < y0 || ypx > y1) return;

    const x = xa.p2c(xpx - xa._offset);
    const y = ya.p2c(ypx - ya._offset);

    cursorEl.textContent = `x: ${fmt(x)}\ny: ${fmt(y)}`;
  }, {passive:true});

  // Optional: click on 2D to copy (x,y) to clipboard
  gd2.addEventListener("click", async (e)=>{
    if(CURRENT_MODE!=="2d") return;
    if(!gd2._fullLayout || !gd2._fullLayout.xaxis || !gd2._fullLayout.yaxis) return;

    const rect = gd2.getBoundingClientRect();
    const xpx = e.clientX - rect.left;
    const ypx = e.clientY - rect.top;

    const xa = gd2._fullLayout.xaxis;
    const ya = gd2._fullLayout.yaxis;
    const x0 = xa._offset, x1 = xa._offset + xa._length;
    const y0 = ya._offset, y1 = ya._offset + ya._length;
    if(xpx < x0 || xpx > x1 || ypx < y0 || ypx > y1) return;

    const x = xa.p2c(xpx - xa._offset);
    const y = ya.p2c(ypx - ya._offset);

    const txt = `${x}, ${y}`;
    try{ await navigator.clipboard.writeText(txt); }catch(_){}
    // Also show in Selection panel for convenience
    selEl.textContent = JSON.stringify({mode:"2d", cursor:{x, y}}, null, 2);
  });
}

function attachPick(){
  const gd3=document.getElementById("plot3d"), gd2=document.getElementById("plot2d");
  gd3.on?.("plotly_click",(ev)=>{const p=ev?.points?.[0]; if(!p) return; selEl.textContent=JSON.stringify({mode:"3d",trace:p.data?.name,x:p.x,y:p.y,z:p.z},null,2);});
  gd2.on?.("plotly_click",(ev)=>{const p=ev?.points?.[0]; if(!p) return; selEl.textContent=JSON.stringify({mode:"2d",trace:p.data?.name,x:p.x,y:p.y},null,2);});
}
setTimeout(()=>{attachPick(); attachCursor2D();},800);
</script>
</body>
</html>
