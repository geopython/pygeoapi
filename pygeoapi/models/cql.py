# generated by datamodel-codegen:
#   filename:  cql-schema.json
#   timestamp: 2021-03-13T21:05:20+00:00

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field


# class CQLModel(BaseModel):
#     __root__: Dict[str, Any]

# class CQL_Model(BaseModel):
#     __root__: Union[
#         ComparisonPredicate,
#         SpatialPredicate,
#         TemporalPredicate
#     ]

#     def __iter__(self):
#         return iter(self.__root__)

#     def __getattr__(self, item):
#         return self.__root__[item]


class CQLModel(BaseModel):
    __root__: Union[
        ComparisonPredicate,
        SpatialPredicate,
        TemporalPredicate,
        AndExpression
    ]


class AndExpression(BaseModel):
    and_: List[ComparisonPredicate] = Field(..., alias='and')


class NotExpression(BaseModel):
    not_: List[Any] = Field(..., alias='not', max_items=1, min_items=1)


class OrExpression(BaseModel):
    or_: List[Any] = Field(..., alias='or', min_items=2)


class PropertyRef(BaseModel):
    property: Optional[str] = None


class ScalarLiteral(BaseModel):
    __root__: Union[str, float, bool]


class Bbox(BaseModel):
    __root__: List[float]


class LineStringType(Enum):
    LineString = 'LineString'


class LinestringCoordinate(BaseModel):
    __root__: List[Any]


class Linestring(BaseModel):
    type: LineStringType
    coordinates: List[LinestringCoordinate] = Field(..., min_items=2)
    bbox: Optional[List[float]] = Field(None, min_items=4)


class MultiLineStringType(Enum):
    MultiLineString = 'MultiLineString'


class MultilineStringCoordinate(BaseModel):
    __root__: List[Any]


class Multilinestring(BaseModel):
    type: MultiLineStringType
    coordinates: List[List[MultilineStringCoordinate]]
    bbox: Optional[List[float]] = Field(None, min_items=4)


class MultiPointType(Enum):
    MultiPoint = 'MultiPoint'


class Multipoint(BaseModel):
    type: MultiPointType
    coordinates: List[List[float]]
    bbox: Optional[List[float]] = Field(None, min_items=4)


class MultiPolygonType(Enum):
    MultiPolygon = 'MultiPolygon'


class MultipolygonCoordinateItem(BaseModel):
    __root__: List[Any]


class Multipolygon(BaseModel):
    type: MultiPolygonType
    coordinates: List[List[List[MultipolygonCoordinateItem]]]
    bbox: Optional[List[float]] = Field(None, min_items=4)


class PointType(Enum):
    Point = 'Point'


class Point(BaseModel):
    type: PointType
    coordinates: List[float] = Field(..., min_items=2)
    bbox: Optional[List[float]] = Field(None, min_items=4)


class PolygonType(Enum):
    Polygon = 'Polygon'


class PolygonCoordinatesItem(BaseModel):
    __root__: List[Any]


class Polygon(BaseModel):
    type: PolygonType
    coordinates: List[List[PolygonCoordinatesItem]]
    bbox: Optional[List[float]] = Field(None, min_items=4)


class TimeString(BaseModel):
    __root__: Union[date, datetime]


class EnvelopeLiteral(BaseModel):
    bbox: Bbox


class GeometryLiteral(BaseModel):
    __root__: Union[
        Point, Linestring, Polygon, Multipoint, Multilinestring, Multipolygon
    ]


class TypedTimeString(BaseModel):
    datetime: TimeString


class PeriodString(BaseModel):
    __root__: List[Union[TimeString, str]] = Field(..., max_items=2, min_items=2)


class SpatialLiteral(BaseModel):
    __root__: Union[GeometryLiteral, EnvelopeLiteral]


class TemporalLiteral(BaseModel):
    __root__: Union[TimeString, PeriodString]


class TypedPeriodString(BaseModel):
    datetime: PeriodString


class TypedTemporalLiteral(BaseModel):
    __root__: Union[TypedTimeString, TypedPeriodString]


class ArrayPredicate(BaseModel):
    __root__: Union[
        AequalsExpression,
        AcontainsExpression,
        AcontainedByExpression,
        AoverlapsExpression,
    ]


class ComparisonPredicate(BaseModel):
    __root__: Union[
        BinaryComparisonPredicate,
        IsLikePredicate,
        IsBetweenPredicate,
        IsInListPredicate,
        IsNullPredicate,
    ]


class SpatialPredicate(BaseModel):
    __root__: Union[
        IntersectsExpression,
        EqualsExpression,
        DisjointExpression,
        TouchesExpression,
        WithinExpression,
        OverlapsExpression,
        CrossesExpression,
        ContainsExpression,
    ]


class TemporalPredicate(BaseModel):
    __root__: Union[
        BeforeExpression,
        AfterExpression,
        MeetsExpression,
        MetbyExpression,
        ToverlapsExpression,
        OverlappedbyExpression,
        BeginsExpression,
        BegunbyExpression,
        DuringExpression,
        TcontainsExpression,
        EndsExpression,
        EndedbyExpression,
        TequalsExpression,
        AnyinteractsExpression,
    ]


class AcontainedByExpression(BaseModel):
    acontainedBy: ArrayExpression


class AcontainsExpression(BaseModel):
    acontains: ArrayExpression


class AequalsExpression(BaseModel):
    aequals: ArrayExpression


class AfterExpression(BaseModel):
    after: TemporalOperands


class AnyinteractsExpression(BaseModel):
    anyinteracts: TemporalOperands


class AoverlapsExpression(BaseModel):
    aoverlaps: ArrayExpression


class BeforeExpression(BaseModel):
    before: TemporalOperands


class BeginsExpression(BaseModel):
    begins: TemporalOperands


class BegunbyExpression(BaseModel):
    begunby: TemporalOperands


class BinaryComparisonPredicate(BaseModel):
    __root__: Union[
        EqExpression, LtExpression, GtExpression, LteExpression, GteExpression
    ]


class ContainsExpression(BaseModel):
    contains: SpatialOperands


class CrossesExpression(BaseModel):
    crosses: SpatialOperands


class DisjointExpression(BaseModel):
    disjoint: SpatialOperands


class DuringExpression(BaseModel):
    during: TemporalOperands


class EndedbyExpression(BaseModel):
    endedby: TemporalOperands


class EndsExpression(BaseModel):
    ends: TemporalOperands


class EqualsExpression(BaseModel):
    equals: SpatialOperands


class IntersectsExpression(BaseModel):
    intersects: SpatialOperands


class Between(BaseModel):
    value: ValueExpression
    lower: ScalarExpression
    upper: ScalarExpression


class IsBetweenPredicate(BaseModel):
    between: Between


class In(BaseModel):
    value: ValueExpression
    list: List[ValueExpression]
    nocase: Optional[bool] = True


class IsInListPredicate(BaseModel):
    in_: In = Field(..., alias='in')


class IsLikePredicate(BaseModel):
    like: ScalarOperands
    wildcard: Optional[str] = '%'
    singleChar: Optional[str] = '.'
    escapeChar: Optional[str] = '\\'
    nocase: Optional[bool] = True


class IsNullPredicate(BaseModel):
    isNull: ScalarExpression


class MeetsExpression(BaseModel):
    meets: TemporalOperands


class MetbyExpression(BaseModel):
    metby: TemporalOperands


class OverlappedbyExpression(BaseModel):
    overlappedby: TemporalOperands


class OverlapsExpression(BaseModel):
    overlaps: SpatialOperands


class TcontainsExpression(BaseModel):
    tcontains: TemporalOperands


class TequalsExpression(BaseModel):
    tequals: TemporalOperands


class TouchesExpression(BaseModel):
    touches: SpatialOperands


class ToverlapsExpression(BaseModel):
    toverlaps: TemporalOperands


class WithinExpression(BaseModel):
    within: SpatialOperands


class ArrayExpression(BaseModel):
    __root__: List[Union[PropertyRef, FunctionRef, ArrayLiteral]] = Field(
        ...# , max_items=2, min_items=2
    )


class EqExpression(BaseModel):
    eq: ScalarOperands


class GtExpression(BaseModel):
    gt: ScalarOperands


class GteExpression(BaseModel):
    gte: ScalarOperands


class LtExpression(BaseModel):
    lt: ScalarOperands


class LteExpression(BaseModel):
    lte: ScalarOperands


class ScalarExpression(BaseModel):
    __root__: Union[ScalarLiteral, PropertyRef, FunctionRef, ArithmeticExpression]


class ScalarOperands(BaseModel):
    __root__: List[ScalarExpression] = Field(..., max_items=2, min_items=2)


class SpatialOperands(BaseModel):
    __root__: List[GeomExpression] = Field(...) # , max_items=2, min_items=2)


class TemporalOperands(BaseModel):
    __root__: List[TemporalExpression] = Field(...) # , max_items=2, min_items=2)


class ValueExpression(BaseModel):
    __root__: Union[ScalarExpression, SpatialLiteral, TypedTemporalLiteral]


class ArithmeticExpression(BaseModel):
    __root__: Union[AddExpression, SubExpression, MulExpression, DivExpression]


class ArrayLiteral(BaseModel):
    __root__: List[
        Union[
            ScalarLiteral,
            SpatialLiteral,
            TypedTemporalLiteral,
            PropertyRef,
            FunctionRef,
            ArithmeticExpression,
            ArrayLiteral,
        ]
    ]


class FunctionRef(BaseModel):
    function: Function


class GeomExpression(BaseModel):
    __root__: Union[SpatialLiteral, PropertyRef, FunctionRef]


class TemporalExpression(BaseModel):
    __root__: Union[TemporalLiteral, PropertyRef, FunctionRef]


class AddExpression(BaseModel):
    _: ArithmeticOperands = Field(..., alias='+')


class DivExpression(BaseModel):
    _: Optional[ArithmeticOperands] = Field(None, alias='/')


class Function(BaseModel):
    name: str
    arguments: Optional[
        List[
            Union[
                ScalarLiteral,
                SpatialLiteral,
                TypedTemporalLiteral,
                PropertyRef,
                FunctionRef,
                ArithmeticExpression,
                ArrayLiteral,
            ]
        ]
    ] = None


class MulExpression(BaseModel):
    _: ArithmeticOperands = Field(..., alias='*')


class SubExpression(BaseModel):
    _: ArithmeticOperands = Field(..., alias='-')


class ArithmeticOperands(BaseModel):
    __root__: List[
        Union[ArithmeticExpression, PropertyRef, FunctionRef, float]
    ] = Field(..., max_items=2, min_items=2)


CQLModel.update_forward_refs()
AndExpression.update_forward_refs()
ArrayPredicate.update_forward_refs()
ComparisonPredicate.update_forward_refs()
SpatialPredicate.update_forward_refs()
TemporalPredicate.update_forward_refs()
AcontainedByExpression.update_forward_refs()
AcontainsExpression.update_forward_refs()
AequalsExpression.update_forward_refs()
AfterExpression.update_forward_refs()
AnyinteractsExpression.update_forward_refs()
AoverlapsExpression.update_forward_refs()
BeforeExpression.update_forward_refs()
BeginsExpression.update_forward_refs()
BegunbyExpression.update_forward_refs()
BinaryComparisonPredicate.update_forward_refs()
ContainsExpression.update_forward_refs()
CrossesExpression.update_forward_refs()
DisjointExpression.update_forward_refs()
DuringExpression.update_forward_refs()
EndedbyExpression.update_forward_refs()
EndsExpression.update_forward_refs()
EqualsExpression.update_forward_refs()
IntersectsExpression.update_forward_refs()
Between.update_forward_refs()
In.update_forward_refs()
IsLikePredicate.update_forward_refs()
IsNullPredicate.update_forward_refs()
MeetsExpression.update_forward_refs()
MetbyExpression.update_forward_refs()
OverlappedbyExpression.update_forward_refs()
OverlapsExpression.update_forward_refs()
TcontainsExpression.update_forward_refs()
TequalsExpression.update_forward_refs()
TouchesExpression.update_forward_refs()
ToverlapsExpression.update_forward_refs()
WithinExpression.update_forward_refs()
ArrayExpression.update_forward_refs()
EqExpression.update_forward_refs()
GtExpression.update_forward_refs()
GteExpression.update_forward_refs()
LtExpression.update_forward_refs()
LteExpression.update_forward_refs()
ScalarExpression.update_forward_refs()
SpatialOperands.update_forward_refs()
TemporalOperands.update_forward_refs()
ArithmeticExpression.update_forward_refs()
ArrayLiteral.update_forward_refs()
FunctionRef.update_forward_refs()
AddExpression.update_forward_refs()
DivExpression.update_forward_refs()
MulExpression.update_forward_refs()
SubExpression.update_forward_refs()


def get_next_node(obj):
    logical_op = None
    if obj.__repr_name__() == 'AndExpression':
        next_node = obj.and_
        logical_op = 'and'
    elif obj.__repr_name__() ==  'OrExpression':
        next_node = obj.or_
        logical_op = 'or'
    elif obj.__repr_name__() ==  'NotExpression':
        next_node = obj.not_
        logical_op = 'not'
    elif obj.__repr_name__() ==  'ComparisonPredicate':
        next_node = obj.__root__
    elif obj.__repr_name__() ==  'SpatialPredicate':
        next_node = obj.__root__
    elif obj.__repr_name__() ==  'TemporalPredicate':
        next_node = obj.__root__
    elif obj.__repr_name__() == 'IsBetweenPredicate':
        next_node = obj.between
    elif obj.__repr_name__() ==  'Between':
        next_node = obj.value
    elif obj.__repr_name__() ==  'ValueExpression':
        next_node = obj.__root__ or obj.lower or obj.upper
    elif obj.__repr_name__() ==  'ScalarExpression':
        next_node = obj.__root__
    elif obj.__repr_name__() ==  'ScalarLiteral':
        next_node = obj.__root__
    elif obj.__repr_name__() ==  'PropertyRef':
        next_node = obj.property
    elif obj.__repr_name__() ==  'BinaryComparisonPredicate':
        next_node = obj.__root__
    elif obj.__repr_name__() ==  'EqExpression':
        next_node = obj.eq
        logical_op = 'eq'
    else:
        raise ValueError("Object not valid")

    return (logical_op, next_node)
